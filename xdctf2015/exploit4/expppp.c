#include <netinet/in.h>    // for sockaddr_in
#include <sys/types.h>    // for socket
#include <sys/socket.h>    // for socket
#include <stdio.h>        // for printf
#include <stdlib.h>        // for exit
#include <strings.h>       // for bzero
#include <unistd.h>       //for fork
#include <string.h> 
#include <math.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>   // for signal


/*
 *This is a very classic Information Disclosure Vulnerability
 *Both libzip and heartbleed have the same  vulnerability.
*/
 /*
 *To increase the difficulty,we constructed an integer overflow in this program
*/

#define EOCD_MAGIC    "PK\1\2"
#define LENGTH_OF_LISTEN_QUEUE 5
#define PORT 8888 


int send_welcome(int fd)
{
    FILE *stream; 
    char buf[128];
    int wel_len,buflen;
    stream = fopen("welcome.txt", "r");
    fseek(stream,0L,SEEK_END);  
    int len=ftell(stream);    //get the size of welcome file

    fseek(stream,0,SEEK_SET);  
    if (stream )
    {
        buflen = fread(buf, 1, len, stream);
        fclose(stream);
        wel_len= write(fd, buf, buflen);
        // printf("welcome string is %s\n",buf);
        return 1;
    }
    else
        return 0;
}


int put_flag_mem(int fd, char *buf)
{
    FILE *stream; 

    stream = fopen("flag.txt", "r");
    fseek(stream,0L,SEEK_END);  
    int flag_len=ftell(stream);    //get the size of flag file
    
    fseek(stream,0L,SEEK_SET);  
    if (stream)
    {
        fgets(buf,flag_len,stream);
        fclose(stream);
        return 1;
    }
    else
        return 0;
}


unsigned char *zip_memmem(unsigned char *big, int biglen, unsigned char *little, int littlelen)
{
    unsigned char *p;
    
    if ((biglen < littlelen) || (littlelen == 0))
        return NULL;
    p = big-1;
    while ((p=(unsigned char *)memchr(p+1, little[0], (size_t)(big-(p+1)+biglen-littlelen+1)))!= NULL)
    {
        if (memcmp(p+1, little+1, littlelen-1)==0)
            return (unsigned char *)p;
    }

    return NULL;
}


static char *
_zip_readstr(unsigned char **buf, int len, int nulp)
{
    char *r, *o;

    r = (char *)malloc(nulp ? len+1 : len);
    if (!r) {
        printf("zip_read_st malloc heap wrong!");
        return NULL;
    }
    // if we find memcpy len is big than size of buf,so we will think that an information leak bug!
    memcpy(r, *buf, len);
    *buf += len;

    if (nulp) {
    /* replace any in-string NUL characters with spaces */
    r[len] = 0;
    for (o=r; o<r+len; o++)
        if (*o == '\0')
        *o = ' ';
    }

    return r;
}


unsigned short
_zip_read2(unsigned char **a)
{
    unsigned short ret;

    ret = (*a)[0]+((*a)[1]<<8);
    *a += 2;

    return ret;
}


void interaction_client(int ss)
{
    int recv_data_len,w_len;
    unsigned short filename_len,filename_len_2;

    char welcome_string;
    char return_string[] = "\nTime is precious, continue to refuel, wish you all smoothly!";
    unsigned char *recv_buf = NULL ,*flag_buf =NULL,*matchaddr,*cur;
    char temp[5];

    char *filename = NULL;

    struct sockaddr_in  client_start,client_end;
    socklen_t  client_start_len = sizeof(client_start);
    getpeername(ss , (struct sockaddr*)&client_start, &client_start_len); 
    printf("expppp:get client from:(%s,%d)\n",inet_ntoa(client_start.sin_addr),ntohs(client_start.sin_port));


    if(!send_welcome(ss)){                                //send welcome string
        printf("Failed send welcome string\n");
        goto cleanup_exit;
    }

     /*copy the 2.zip into the heap memory*/
    if ((recv_buf=(unsigned char *)malloc(0x94+2)) == NULL) {     // malloc heap for recv data
        printf("malloc for recv data failed!\n");
        goto cleanup_exit;
    }

     recv_data_len = read(ss, recv_buf, 0x94);            //read data from socket  
     printf("recv dat  length is:%d\n",recv_data_len);      
     if (recv_data_len < 0x30){  //confirm that +0x1c +0x10 point have data
            printf("The length of recv data is too short!close the socket\n");
            goto cleanup_exit;
    }

    if ((flag_buf=(unsigned char *)malloc(0x30)) == NULL) {     // malloc heap for flag
        printf("malloc failed!\n");
        goto cleanup_exit;
    }

    if(!put_flag_mem(ss,flag_buf)){                    //put the flag into memory(heap)
        printf("Failed put flag string in memory\n");
        goto cleanup_exit;
    }

    /* Integer Overflow */
    /* Began to leak information */

    /*find the 'Central directory file header'->the second struct part of zip*/
    matchaddr = recv_buf;
    matchaddr = zip_memmem(matchaddr,recv_data_len,(unsigned char *)EOCD_MAGIC,4);
    if(!matchaddr){
        printf("match PK12 error!\n");
        goto cleanup_exit;
    }
    memcpy(temp,matchaddr,4);
    temp[4]='\0';

    if(strcmp((char *)temp,(char *)EOCD_MAGIC)){
        printf("Sorry,strcmp matchaddr is NOT EOCD_MAGIC!\n");
        goto cleanup_exit;
    }

    /*in order to ensure that it has enough space to read filename_len and filename*/
    if((matchaddr - recv_buf)+0x30 > recv_data_len){ 
        printf("Sorry,not enough space to read filename _len and file name!\n");
        goto cleanup_exit;
    }

    cur = matchaddr + 28; // offset of file name length (n)
    filename_len = _zip_read2(&cur);
    printf("file name length is %d\n",filename_len);

    cur += 0x10;  //offset of file name addr

    /* Integer Overflow */
    filename_len_2 = filename_len + 2;

    if(filename_len_2 > recv_data_len - (matchaddr - recv_buf) - 46){
        printf("[+] File name length is too long!!!\n");
        goto cleanup_exit;
    }

    /* read too many data to fiilename buf*/
    if (filename_len)
        filename = _zip_readstr(&cur,filename_len,1);

    w_len= write(ss, filename, strlen(filename));

cleanup_exit:
    if(recv_buf)
        free(recv_buf);
    if(flag_buf)
        free(flag_buf);
    if(filename)
        free(filename);

    write(ss, return_string, strlen(return_string));

    close(ss);
    exit(0);
}


int main(int argc, char **argv)
{
    int pid;
    //设置一个socket地址结构server_addr,代表服务器internet地址, 端口
    struct sockaddr_in server_addr;
    bzero(&server_addr,sizeof(server_addr)); //把一段内存区的内容全部设置为0
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htons(INADDR_ANY);
    server_addr.sin_port = htons(PORT);
 
    //创建用于internet的流协议(TCP)socket,用server_socket代表服务器socket
    int server_socket = socket(PF_INET,SOCK_STREAM,0);
    if( server_socket < 0)
    {
        printf("FATAL ERROR opening socket!\n");
        exit(1);
    }


    int opt =1;
    setsockopt(server_socket,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));

     
    //把socket和socket地址结构联系起来
    if( bind(server_socket,(struct sockaddr*)&server_addr,sizeof(server_addr)))
    {
        printf("Server Bind Port : %d Failed!\n", PORT); 
        exit(1);
    }
 
    //server_socket用于监听
    if (listen(server_socket, LENGTH_OF_LISTEN_QUEUE) )
    {
        printf("Server Listen Failed!\n"); 
        exit(1);
    }


    signal (SIGCHLD, SIG_IGN);
    printf("server is listening....\n");


    while (1) //服务器端要一直运行
    {

  //     printf("server is listening....\n");

        //定义客户端的socket地址结构client_addr
        struct sockaddr_in client_addr;
        socklen_t length = sizeof(client_addr);
 
        //接受一个到server_socket代表的socket的一个连接
        //如果没有连接请求,就等待到有连接请求--这是accept函数的特性
        //accept函数返回一个新的socket,这个socket(ss)用于同连接到的客户的通信
        //ss代表了服务器和客户端之间的一个通信通道
        //accept函数把连接到的客户端信息填写到客户端的socket地址结构client_addr中
        int ss = accept(server_socket,(struct sockaddr*)&client_addr,&length);
        if ( ss < 0)
        {
            printf("Server Accept Failed!\n");
            break;
        }

        pid = fork();
        if ( pid < 0 )
            break;
        if ( !pid )
        {
            if ( ss < 0 )
            {
                printf("FATAL ERROR: could not accept connections\n");
                exit(1);
            }
            close(server_socket);
            interaction_client(ss);
            exit(0);
        }
        close(ss);
    }
    printf("FATAL ERROR: could not fork\n");
    exit(1);

    return 1;
}
